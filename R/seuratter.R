#' Calculates The Optimum Dimensionality From An Elbow Plot.
#'
#' A function that calculates the optimum dimensionality from an elbow plot. Involves calculating
#' slopes of the lines that begin from each point to the last point. The optimum dimensionality will
#' be determined as the point at which slopes no longer change or no visible change occurs to the slopes
#' thereafter. The plot data must be plotted by dims (x-axis) and stdev (y-axis).
#'
#' @param plot An elbow plot data used for detemining dimensionality, generated by calling ElbowPlot() on a Seurat object.
#'
#' @return Returns an integer that represents the dimensionality that was determined by calculation.
#'
#' @export
determine_dimensionality <- function(plot_data) {

  dimensions <- plot_data$dims
  total_dims <- length(dimensions)
  stdev <- plot_data$stdev
  slopes_so_far <- c()
  last_dim <- length(dimensions)

  for (dim in 2:last_dim) {
    slopes_so_far <- c(slopes_so_far, (stdev[dim] - stdev[dim - 1]))
  }

  dimensionality <- 1
  nth_point <- 2
  for (slope in slopes_so_far) {
    if (slope > 10 * max(slopes_so_far) && stdev[nth_point] < min(stdev) + ((max(stdev) - min(stdev)) * 0.05)) {
      print(slope)
      dimensionality <- nth_point
      return(dimensionality - 1)
    }
    nth_point <- nth_point + 1
  }

  return(dimensionality)

}




#' Extracts Genes Expressed By A Cluster.
#'
#' A function that utilizes a Seurat function to identify and extract gene expression profiles (both positive and negative expressions) of
#' a cluster. Involves identifying all genes expressed by more than a certain percentage of cells (recommend 0.25) in the cluster and
#' does not take into account the uniquesness of expression among other clusters. In other words, does not focus on cluster specific genes
#' but also involves genes that are generally expressed.
#'
#'
#' @param seurat_object A Seurat object that has undergone the entire workflow, involving UMAP.
#' @param cluster_num An integer representing the cluster.
#' @param min_percent A float representing the percentage of cells that have to express the gene to be included in the result.
#'
#' @return Returns a vector of gene names that are expressed by the cluster identified by cluster_num
#'
#' @export
extract_genes_expressed <- function(seurat_object, cluster_num, min_percent) {

  cluster_markers <- FindMarkers(seurat_object, ident.1 = cluster_num, min.pct = min_percent)
  return(rownames(cluster_markers))

}

#' Compare And Extract Coexpressed Genes In Two Clusters
#'
#' A function that compares and compiles all the genes identified by extract_genes_expressed into one matrix
#'
#' @param seurat_object A Seurat object that has undergone the entire workflow, involving UMAP.
#'
#' @return Returns a matrix of cluster id by cluster id, with each matrix cell (x,y) containing the vector genes expressed by both clusters x and y.
#'
#' @export
get_same_genes <- function() {

}



#' Compares Genes Expressed In Each Cluster.
#'
#' A function that compares and compiles all the genes identified by extract_genes_expressed into one matrix
#'
#' @param seurat_object A Seurat object that has undergone the entire workflow, involving UMAP.
#'
#' @return Returns a matrix of cluster id by cluster id, with each matrix cell (x,y) containing the vector genes expressed by both clusters x and y.
#'
#' @export
compare_cluster_genes <- function(seurat_object) {
  clusters <- unique(seurat_object$seurat_clusters)
  num_clusters <- length(clusters)
  row_col_name <- as.character(sort(clusters))
  gene_expressions <- matrix(list(), nrow = num_clusters, ncol = 1, dimnames = list(row_col_name, "genes"))
  gene_comparison_matrix <- matrix(list(), nrow = num_clusters, ncol = num_clusters, dimnames = list(row_col_name, row_col_name))

  for (cluster_id in row.names(gene_expressions)) {
    gene_expressions[cluster_id, "genes"][[1]] <-  extract_genes_expressed(seurat_object, cluster_id, 0.25)
  }

  for (cluster_id_x in row_col_name) {
    for (cluster_id_y in row_col_name) {
      if (cluster_id_x == cluster_id_y) {
        gene_comparison_matrix[cluster_id_x, cluster_id_y][[1]] <- NA
      }
      else if (is.null(gene_comparison_matrix[cluster_id_x, cluster_id_y][[1]])) {
        gene_overlaps <- intersect(gene_expressions[cluster_id_x, "genes"][[1]], gene_expressions[cluster_id_y, "genes"][[1]])
        gene_comparison_matrix[cluster_id_x, cluster_id_y][[1]] <- gene_overlaps
      } else {
        ;
      }
    }
  }

  return(gene_comparison_matrix)
}
