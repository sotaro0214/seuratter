#' Calculates The Optimum Dimensionality From An Elbow Plot.
#'
#' A function that calculates the optimum dimensionality from an elbow plot. Involves calculating
#' slopes between two consecutive points. The optimum dimensionality will be determined as the point at
#' which slopes no longer change or no visible change occurs to the slopes thereafter. In this function, a dimension
#' is determined optimal when a slope connecting that point to another is flatter than 10 times the flattest slope
#' in the plot and the stdev at that point is proximal to the lower limit.
#' The plot data must be plotted by dims (x-axis) and stdev (y-axis).
#'
#' @param plot An elbow plot data used for detemining dimensionality, generated by calling ElbowPlot() on a Seurat object.
#'
#' @return Returns an integer that represents the optimal dimensionality that was determined by calculation.
#'
#' @export
determine_dimensionality <- function(plot_data) {

  # Prepare all required parameters from plot_data.
  dimensions <- plot_data$dims
  total_dims <- length(dimensions)
  stdev <- plot_data$stdev
  slopes_so_far <- c() # Will keep track of all the slopes (between two consecutive points) calculated.
  last_dim <- length(dimensions)

  # Calculates slopes between every pair of consecutive points.
  for (dim in 2:last_dim) {
    slopes_so_far <- c(slopes_so_far, (stdev[dim] - stdev[dim - 1]))
  }

  # Default dimensionality to return is 1.
  dimensionality <- 1
  nth_point <- 2
  for (slope in slopes_so_far) {
    # After trial and error, these conditions seem to work well to determine the elbow.
    # Note: slopes are negative in this plot, so using max(slopes_so_far).
    # The first condition looks to see if we are approaching a lower limit, but this wouldn't be enough to
    # confidently say that it is, so we need the second condition.
    # The second condition makes sure that the point used to determine the slope is very close to the
    # smallest value, which means that it increases the confidence that this slope is indeed approaching
    # a lower limit.
    if (slope > 10 * max(slopes_so_far) && stdev[nth_point] < min(stdev) + ((max(stdev) - min(stdev)) * 0.05)) {
      dimensionality <- nth_point
      return(dimensionality - 1) # Subtract 1 because we want the point that leads into the lower limit or the
                                 # flat part of the graph.
    }
    nth_point <- nth_point + 1
  }

  # The function could not determine dimensionality or elbow from the plot.
  return(dimensionality)

}




#' Extracts Genes Expressed By A Cluster.
#'
#' A function that utilizes a Seurat function to identify and extract gene expression profiles (both positive
#' and negative expressions) of a cluster. Involves identifying all genes expressed by more than a certain
#' percentage of cells (recommend 0.25 by Seurat author) in the cluster and does not take into account the uniquesness of
#' expression among the clusters. In other words, function does not focus on cluster specific genes but
#' also involves genes that are generally expressed (Seurat focuses on cluster specific genes).
#'
#' @param seurat_object A Seurat object that has undergone the entire workflow, involving UMAP.
#' @param cluster_num An integer representing the cluster.
#' @param min_percent A float representing the percentage of cells that have to express the gene to be
#' included in the result.
#'
#' @return Returns a vector of gene names that are expressed by the cluster identified by cluster_num in more
#' than min_percent of the cells in the cluser.
#'
#' @export
extract_genes_expressed <- function(seurat_object, cluster_num, min_percent) {

  cluster_markers <- FindMarkers(seurat_object, ident.1 = cluster_num, min.pct = min_percent)
  return(rownames(cluster_markers)) # We only want to return the names of the genes (ie. rownames).

}


#' Compares Genes Expressed In Each Cluster.
#'
#' A function that compares and compiles all the genes identified by extract_genes_expressed() into one matrix. Does
#' this by determining the gene expressions that overlap between clusters and mapping that information into
#' the matrix.
#'
#' @param seurat_object A Seurat object that has undergone the entire workflow, involving UMAP.
#'
#' @return Returns a matrix of number of clusters by number of clusters, with each matrix cell (x,y)
#' containing the vector of genes expressed by both clusters x and y.
#'
#' @export
compare_cluster_genes <- function(seurat_object) {

  # Preparing data for manipulation.
  clusters <- unique(seurat_object$seurat_clusters)
  num_clusters <- length(clusters)
  row_col_name <- as.character(sort(clusters)) # Used for row and column of the matrix and they have to be chars.

  # Prepare matrices to input the data.
  # First matri is to first compile all the gene expression data for each cluster, generated
  # by extract_genes_expressed.
  # Second matrix is to keep the genes that were determined to overlap between clusters.
  gene_expressions <- matrix(list(), nrow = num_clusters, ncol = 1, dimnames = list(row_col_name, "genes"))
  gene_comparison_matrix <- matrix(list(), nrow = num_clusters, ncol = num_clusters, dimnames = list(row_col_name, row_col_name))

  # Iterate through each cluster and extract genes expressed.
  for (cluster_id in row.names(gene_expressions)) {
    gene_expressions[cluster_id, "genes"][[1]] <-  extract_genes_expressed(seurat_object, cluster_id, 0.25)
  }

  # For each pair of clusters, determine the overlapping gene expressions and store them in a matrix.
  for (cluster_id_x in row_col_name) {
    for (cluster_id_y in row_col_name) {
      if (cluster_id_x == cluster_id_y) {
        gene_comparison_matrix[cluster_id_x, cluster_id_y][[1]] <- NA
      }
      else if (is.null(gene_comparison_matrix[cluster_id_x, cluster_id_y][[1]])) {
        gene_overlaps <-
          intersect(gene_expressions[cluster_id_x, "genes"][[1]], gene_expressions[cluster_id_y, "genes"][[1]])
        gene_comparison_matrix[cluster_id_x, cluster_id_y][[1]] <- gene_overlaps
      } else {
        ;
      }
    }
  }

  return(gene_comparison_matrix)
}



#' Plot A Graph Representing Gene Expression Relationships Between Clusters
#'
#' Plot a graph representing the gene expression relationships between clusters. The edge thickness depends
#' on how many genes the clusters share between each other. The more of the same genes they express, the thicker
#' stronger their relationship is.
#'
#' @param gene_comparison_matrix A matrix object of number of cluster by number of clusters cells, with each
#' matrix cell (x,y) containing the vector of genes expressed by both clusters x and y.
#'
#' @return Returns a plot of nodes and edges, where node (number represents cluster id) represents a cluster
#' and an edge between nodes represent the genes shared by those clusters.
#'
#' @export
draw_cluster_gene_relations <- function(gene_comparison_matrix) {

  # Create a clone of the input matrix because we will replace each cell by counts of genes that overlap
  # (ie. the length of the vector that occupied that cell).
  another_matrix <- cbind(gene_comparison_matrix)
  first_cluster <- head(row.names(gene_comparison_matrix), 1)
  last_cluster <- tail(row.names(gene_comparison_matrix), 1)

  # For every pair of clusters, replace the gene expression vectors with its size/count, so that
  # we can use it for edge width.
  for (cluster_x in first_cluster:last_cluster) {
    for (cluster_y in first_cluster:last_cluster) {
      if (length(another_matrix[as.character(cluster_x), as.character(cluster_y)][[1]]) == 1 &&
          is.na(another_matrix[as.character(cluster_x), as.character(cluster_y)][[1]])) {
        another_matrix[as.character(cluster_x), as.character(cluster_y)][[1]] <- 0
      } else {
        another_matrix[as.character(cluster_x), as.character(cluster_y)][[1]] <-
          length(another_matrix[as.character(cluster_x), as.character(cluster_y)][[1]])
      }
    }
  }

  graph <- graph_from_adjacency_matrix(another_matrix, mode="undirected", weighted = TRUE)

  # This edge.width setting emphasizes the differences the most.
  return(plot(g, edge.width = 5 * (E(g)$weight / max(E(g)$weight)) ** 2))
}
